/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface TestnetDualTokenAdapterInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "TBNB"
      | "addLiquidity"
      | "buyNoWithBNB"
      | "buyNoWithPDX"
      | "buyYesWithBNB"
      | "buyYesWithPDX"
      | "cancelOrder"
      | "claimRedemption"
      | "createMarketWithBNB"
      | "createMarketWithPDX"
      | "createStopLossOrder"
      | "createTakeProfitOrder"
      | "dexRouter"
      | "executeOrder"
      | "getMarketPaymentToken"
      | "getMinBNBForPDX"
      | "getMinPDXForBNB"
      | "marketPaymentToken"
      | "owner"
      | "pdxToken"
      | "predictionMarket"
      | "removeLiquidity"
      | "sellNoForBNB"
      | "sellNoForPDX"
      | "sellYesForBNB"
      | "sellYesForPDX"
      | "setSlippageTolerance"
      | "slippageTolerance"
      | "transferOwnership"
      | "withdrawBNB"
      | "withdrawPDX"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "BNBSwappedToPDX"
      | "BuyWithBNB"
      | "BuyWithPDX"
      | "MarketCreatedWithBNB"
      | "MarketCreatedWithPDX"
      | "PDXSwappedToBNB"
      | "SellForBNB"
      | "SellForPDX"
      | "SlippageToleranceUpdated"
  ): EventFragment;

  encodeFunctionData(functionFragment: "TBNB", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "addLiquidity",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "buyNoWithBNB",
    values: [BigNumberish, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "buyNoWithPDX",
    values: [
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "buyYesWithBNB",
    values: [BigNumberish, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "buyYesWithPDX",
    values: [
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimRedemption",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createMarketWithBNB",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createMarketWithPDX",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "createStopLossOrder",
    values: [BigNumberish, boolean, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createTakeProfitOrder",
    values: [BigNumberish, boolean, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "dexRouter", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "executeOrder",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getMarketPaymentToken",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getMinBNBForPDX",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getMinPDXForBNB",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "marketPaymentToken",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "pdxToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "predictionMarket",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "removeLiquidity",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sellNoForBNB",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sellNoForPDX",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sellYesForBNB",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sellYesForPDX",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setSlippageTolerance",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "slippageTolerance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawBNB",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawPDX",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "TBNB", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "addLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "buyNoWithBNB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "buyNoWithPDX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "buyYesWithBNB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "buyYesWithPDX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimRedemption",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createMarketWithBNB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createMarketWithPDX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createStopLossOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createTakeProfitOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "dexRouter", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMarketPaymentToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMinBNBForPDX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMinPDXForBNB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketPaymentToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pdxToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "predictionMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellNoForBNB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellNoForPDX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellYesForBNB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sellYesForPDX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSlippageTolerance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "slippageTolerance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawBNB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawPDX",
    data: BytesLike
  ): Result;
}

export namespace BNBSwappedToPDXEvent {
  export type InputTuple = [bnbIn: BigNumberish, pdxOut: BigNumberish];
  export type OutputTuple = [bnbIn: bigint, pdxOut: bigint];
  export interface OutputObject {
    bnbIn: bigint;
    pdxOut: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BuyWithBNBEvent {
  export type InputTuple = [
    marketId: BigNumberish,
    user: AddressLike,
    isYes: boolean,
    bnbAmount: BigNumberish
  ];
  export type OutputTuple = [
    marketId: bigint,
    user: string,
    isYes: boolean,
    bnbAmount: bigint
  ];
  export interface OutputObject {
    marketId: bigint;
    user: string;
    isYes: boolean;
    bnbAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BuyWithPDXEvent {
  export type InputTuple = [
    marketId: BigNumberish,
    user: AddressLike,
    isYes: boolean,
    pdxAmount: BigNumberish,
    bnbConverted: BigNumberish
  ];
  export type OutputTuple = [
    marketId: bigint,
    user: string,
    isYes: boolean,
    pdxAmount: bigint,
    bnbConverted: bigint
  ];
  export interface OutputObject {
    marketId: bigint;
    user: string;
    isYes: boolean;
    pdxAmount: bigint;
    bnbConverted: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MarketCreatedWithBNBEvent {
  export type InputTuple = [
    marketId: BigNumberish,
    creator: AddressLike,
    bnbAmount: BigNumberish
  ];
  export type OutputTuple = [
    marketId: bigint,
    creator: string,
    bnbAmount: bigint
  ];
  export interface OutputObject {
    marketId: bigint;
    creator: string;
    bnbAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MarketCreatedWithPDXEvent {
  export type InputTuple = [
    marketId: BigNumberish,
    creator: AddressLike,
    pdxAmount: BigNumberish
  ];
  export type OutputTuple = [
    marketId: bigint,
    creator: string,
    pdxAmount: bigint
  ];
  export interface OutputObject {
    marketId: bigint;
    creator: string;
    pdxAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PDXSwappedToBNBEvent {
  export type InputTuple = [pdxIn: BigNumberish, bnbOut: BigNumberish];
  export type OutputTuple = [pdxIn: bigint, bnbOut: bigint];
  export interface OutputObject {
    pdxIn: bigint;
    bnbOut: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SellForBNBEvent {
  export type InputTuple = [
    marketId: BigNumberish,
    user: AddressLike,
    isYes: boolean,
    tokenAmount: BigNumberish,
    bnbReceived: BigNumberish
  ];
  export type OutputTuple = [
    marketId: bigint,
    user: string,
    isYes: boolean,
    tokenAmount: bigint,
    bnbReceived: bigint
  ];
  export interface OutputObject {
    marketId: bigint;
    user: string;
    isYes: boolean;
    tokenAmount: bigint;
    bnbReceived: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SellForPDXEvent {
  export type InputTuple = [
    marketId: BigNumberish,
    user: AddressLike,
    isYes: boolean,
    tokenAmount: BigNumberish,
    pdxReceived: BigNumberish
  ];
  export type OutputTuple = [
    marketId: bigint,
    user: string,
    isYes: boolean,
    tokenAmount: bigint,
    pdxReceived: bigint
  ];
  export interface OutputObject {
    marketId: bigint;
    user: string;
    isYes: boolean;
    tokenAmount: bigint;
    pdxReceived: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SlippageToleranceUpdatedEvent {
  export type InputTuple = [newSlippage: BigNumberish];
  export type OutputTuple = [newSlippage: bigint];
  export interface OutputObject {
    newSlippage: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface TestnetDualTokenAdapter extends BaseContract {
  connect(runner?: ContractRunner | null): TestnetDualTokenAdapter;
  waitForDeployment(): Promise<this>;

  interface: TestnetDualTokenAdapterInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  TBNB: TypedContractMethod<[], [string], "view">;

  addLiquidity: TypedContractMethod<
    [marketId: BigNumberish, yesAmount: BigNumberish, noAmount: BigNumberish],
    [void],
    "nonpayable"
  >;

  buyNoWithBNB: TypedContractMethod<
    [marketId: BigNumberish, beneficiary: AddressLike, minNoOut: BigNumberish],
    [void],
    "payable"
  >;

  buyNoWithPDX: TypedContractMethod<
    [
      marketId: BigNumberish,
      beneficiary: AddressLike,
      pdxAmount: BigNumberish,
      minBNBOut: BigNumberish,
      minNoOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  buyYesWithBNB: TypedContractMethod<
    [marketId: BigNumberish, beneficiary: AddressLike, minYesOut: BigNumberish],
    [void],
    "payable"
  >;

  buyYesWithPDX: TypedContractMethod<
    [
      marketId: BigNumberish,
      beneficiary: AddressLike,
      pdxAmount: BigNumberish,
      minBNBOut: BigNumberish,
      minYesOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  cancelOrder: TypedContractMethod<
    [orderId: BigNumberish],
    [void],
    "nonpayable"
  >;

  claimRedemption: TypedContractMethod<
    [marketId: BigNumberish],
    [void],
    "nonpayable"
  >;

  createMarketWithBNB: TypedContractMethod<
    [
      question: string,
      category: string,
      endTime: BigNumberish,
      initialYes: BigNumberish,
      initialNo: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  createMarketWithPDX: TypedContractMethod<
    [
      question: string,
      category: string,
      endTime: BigNumberish,
      initialYes: BigNumberish,
      initialNo: BigNumberish,
      pdxAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  createStopLossOrder: TypedContractMethod<
    [
      marketId: BigNumberish,
      isYes: boolean,
      tokenAmount: BigNumberish,
      stopLossPrice: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  createTakeProfitOrder: TypedContractMethod<
    [
      marketId: BigNumberish,
      isYes: boolean,
      tokenAmount: BigNumberish,
      takeProfitPrice: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  dexRouter: TypedContractMethod<[], [string], "view">;

  executeOrder: TypedContractMethod<
    [orderId: BigNumberish],
    [void],
    "nonpayable"
  >;

  getMarketPaymentToken: TypedContractMethod<
    [marketId: BigNumberish],
    [string],
    "view"
  >;

  getMinBNBForPDX: TypedContractMethod<
    [pdxAmount: BigNumberish],
    [bigint],
    "view"
  >;

  getMinPDXForBNB: TypedContractMethod<
    [bnbAmount: BigNumberish],
    [bigint],
    "view"
  >;

  marketPaymentToken: TypedContractMethod<
    [arg0: BigNumberish],
    [bigint],
    "view"
  >;

  owner: TypedContractMethod<[], [string], "view">;

  pdxToken: TypedContractMethod<[], [string], "view">;

  predictionMarket: TypedContractMethod<[], [string], "view">;

  removeLiquidity: TypedContractMethod<
    [marketId: BigNumberish, lpAmount: BigNumberish],
    [void],
    "nonpayable"
  >;

  sellNoForBNB: TypedContractMethod<
    [
      marketId: BigNumberish,
      tokenAmount: BigNumberish,
      minBNBOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  sellNoForPDX: TypedContractMethod<
    [
      marketId: BigNumberish,
      tokenAmount: BigNumberish,
      minBNBOut: BigNumberish,
      minPDXOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  sellYesForBNB: TypedContractMethod<
    [
      marketId: BigNumberish,
      tokenAmount: BigNumberish,
      minBNBOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  sellYesForPDX: TypedContractMethod<
    [
      marketId: BigNumberish,
      tokenAmount: BigNumberish,
      minBNBOut: BigNumberish,
      minPDXOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  setSlippageTolerance: TypedContractMethod<
    [_slippage: BigNumberish],
    [void],
    "nonpayable"
  >;

  slippageTolerance: TypedContractMethod<[], [bigint], "view">;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  withdrawBNB: TypedContractMethod<[], [void], "nonpayable">;

  withdrawPDX: TypedContractMethod<[], [void], "nonpayable">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "TBNB"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "addLiquidity"
  ): TypedContractMethod<
    [marketId: BigNumberish, yesAmount: BigNumberish, noAmount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "buyNoWithBNB"
  ): TypedContractMethod<
    [marketId: BigNumberish, beneficiary: AddressLike, minNoOut: BigNumberish],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "buyNoWithPDX"
  ): TypedContractMethod<
    [
      marketId: BigNumberish,
      beneficiary: AddressLike,
      pdxAmount: BigNumberish,
      minBNBOut: BigNumberish,
      minNoOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "buyYesWithBNB"
  ): TypedContractMethod<
    [marketId: BigNumberish, beneficiary: AddressLike, minYesOut: BigNumberish],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "buyYesWithPDX"
  ): TypedContractMethod<
    [
      marketId: BigNumberish,
      beneficiary: AddressLike,
      pdxAmount: BigNumberish,
      minBNBOut: BigNumberish,
      minYesOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cancelOrder"
  ): TypedContractMethod<[orderId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "claimRedemption"
  ): TypedContractMethod<[marketId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "createMarketWithBNB"
  ): TypedContractMethod<
    [
      question: string,
      category: string,
      endTime: BigNumberish,
      initialYes: BigNumberish,
      initialNo: BigNumberish
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "createMarketWithPDX"
  ): TypedContractMethod<
    [
      question: string,
      category: string,
      endTime: BigNumberish,
      initialYes: BigNumberish,
      initialNo: BigNumberish,
      pdxAmount: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createStopLossOrder"
  ): TypedContractMethod<
    [
      marketId: BigNumberish,
      isYes: boolean,
      tokenAmount: BigNumberish,
      stopLossPrice: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createTakeProfitOrder"
  ): TypedContractMethod<
    [
      marketId: BigNumberish,
      isYes: boolean,
      tokenAmount: BigNumberish,
      takeProfitPrice: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "dexRouter"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "executeOrder"
  ): TypedContractMethod<[orderId: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getMarketPaymentToken"
  ): TypedContractMethod<[marketId: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "getMinBNBForPDX"
  ): TypedContractMethod<[pdxAmount: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "getMinPDXForBNB"
  ): TypedContractMethod<[bnbAmount: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "marketPaymentToken"
  ): TypedContractMethod<[arg0: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "pdxToken"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "predictionMarket"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "removeLiquidity"
  ): TypedContractMethod<
    [marketId: BigNumberish, lpAmount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sellNoForBNB"
  ): TypedContractMethod<
    [
      marketId: BigNumberish,
      tokenAmount: BigNumberish,
      minBNBOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sellNoForPDX"
  ): TypedContractMethod<
    [
      marketId: BigNumberish,
      tokenAmount: BigNumberish,
      minBNBOut: BigNumberish,
      minPDXOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sellYesForBNB"
  ): TypedContractMethod<
    [
      marketId: BigNumberish,
      tokenAmount: BigNumberish,
      minBNBOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sellYesForPDX"
  ): TypedContractMethod<
    [
      marketId: BigNumberish,
      tokenAmount: BigNumberish,
      minBNBOut: BigNumberish,
      minPDXOut: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setSlippageTolerance"
  ): TypedContractMethod<[_slippage: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "slippageTolerance"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "withdrawBNB"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "withdrawPDX"
  ): TypedContractMethod<[], [void], "nonpayable">;

  getEvent(
    key: "BNBSwappedToPDX"
  ): TypedContractEvent<
    BNBSwappedToPDXEvent.InputTuple,
    BNBSwappedToPDXEvent.OutputTuple,
    BNBSwappedToPDXEvent.OutputObject
  >;
  getEvent(
    key: "BuyWithBNB"
  ): TypedContractEvent<
    BuyWithBNBEvent.InputTuple,
    BuyWithBNBEvent.OutputTuple,
    BuyWithBNBEvent.OutputObject
  >;
  getEvent(
    key: "BuyWithPDX"
  ): TypedContractEvent<
    BuyWithPDXEvent.InputTuple,
    BuyWithPDXEvent.OutputTuple,
    BuyWithPDXEvent.OutputObject
  >;
  getEvent(
    key: "MarketCreatedWithBNB"
  ): TypedContractEvent<
    MarketCreatedWithBNBEvent.InputTuple,
    MarketCreatedWithBNBEvent.OutputTuple,
    MarketCreatedWithBNBEvent.OutputObject
  >;
  getEvent(
    key: "MarketCreatedWithPDX"
  ): TypedContractEvent<
    MarketCreatedWithPDXEvent.InputTuple,
    MarketCreatedWithPDXEvent.OutputTuple,
    MarketCreatedWithPDXEvent.OutputObject
  >;
  getEvent(
    key: "PDXSwappedToBNB"
  ): TypedContractEvent<
    PDXSwappedToBNBEvent.InputTuple,
    PDXSwappedToBNBEvent.OutputTuple,
    PDXSwappedToBNBEvent.OutputObject
  >;
  getEvent(
    key: "SellForBNB"
  ): TypedContractEvent<
    SellForBNBEvent.InputTuple,
    SellForBNBEvent.OutputTuple,
    SellForBNBEvent.OutputObject
  >;
  getEvent(
    key: "SellForPDX"
  ): TypedContractEvent<
    SellForPDXEvent.InputTuple,
    SellForPDXEvent.OutputTuple,
    SellForPDXEvent.OutputObject
  >;
  getEvent(
    key: "SlippageToleranceUpdated"
  ): TypedContractEvent<
    SlippageToleranceUpdatedEvent.InputTuple,
    SlippageToleranceUpdatedEvent.OutputTuple,
    SlippageToleranceUpdatedEvent.OutputObject
  >;

  filters: {
    "BNBSwappedToPDX(uint256,uint256)": TypedContractEvent<
      BNBSwappedToPDXEvent.InputTuple,
      BNBSwappedToPDXEvent.OutputTuple,
      BNBSwappedToPDXEvent.OutputObject
    >;
    BNBSwappedToPDX: TypedContractEvent<
      BNBSwappedToPDXEvent.InputTuple,
      BNBSwappedToPDXEvent.OutputTuple,
      BNBSwappedToPDXEvent.OutputObject
    >;

    "BuyWithBNB(uint256,address,bool,uint256)": TypedContractEvent<
      BuyWithBNBEvent.InputTuple,
      BuyWithBNBEvent.OutputTuple,
      BuyWithBNBEvent.OutputObject
    >;
    BuyWithBNB: TypedContractEvent<
      BuyWithBNBEvent.InputTuple,
      BuyWithBNBEvent.OutputTuple,
      BuyWithBNBEvent.OutputObject
    >;

    "BuyWithPDX(uint256,address,bool,uint256,uint256)": TypedContractEvent<
      BuyWithPDXEvent.InputTuple,
      BuyWithPDXEvent.OutputTuple,
      BuyWithPDXEvent.OutputObject
    >;
    BuyWithPDX: TypedContractEvent<
      BuyWithPDXEvent.InputTuple,
      BuyWithPDXEvent.OutputTuple,
      BuyWithPDXEvent.OutputObject
    >;

    "MarketCreatedWithBNB(uint256,address,uint256)": TypedContractEvent<
      MarketCreatedWithBNBEvent.InputTuple,
      MarketCreatedWithBNBEvent.OutputTuple,
      MarketCreatedWithBNBEvent.OutputObject
    >;
    MarketCreatedWithBNB: TypedContractEvent<
      MarketCreatedWithBNBEvent.InputTuple,
      MarketCreatedWithBNBEvent.OutputTuple,
      MarketCreatedWithBNBEvent.OutputObject
    >;

    "MarketCreatedWithPDX(uint256,address,uint256)": TypedContractEvent<
      MarketCreatedWithPDXEvent.InputTuple,
      MarketCreatedWithPDXEvent.OutputTuple,
      MarketCreatedWithPDXEvent.OutputObject
    >;
    MarketCreatedWithPDX: TypedContractEvent<
      MarketCreatedWithPDXEvent.InputTuple,
      MarketCreatedWithPDXEvent.OutputTuple,
      MarketCreatedWithPDXEvent.OutputObject
    >;

    "PDXSwappedToBNB(uint256,uint256)": TypedContractEvent<
      PDXSwappedToBNBEvent.InputTuple,
      PDXSwappedToBNBEvent.OutputTuple,
      PDXSwappedToBNBEvent.OutputObject
    >;
    PDXSwappedToBNB: TypedContractEvent<
      PDXSwappedToBNBEvent.InputTuple,
      PDXSwappedToBNBEvent.OutputTuple,
      PDXSwappedToBNBEvent.OutputObject
    >;

    "SellForBNB(uint256,address,bool,uint256,uint256)": TypedContractEvent<
      SellForBNBEvent.InputTuple,
      SellForBNBEvent.OutputTuple,
      SellForBNBEvent.OutputObject
    >;
    SellForBNB: TypedContractEvent<
      SellForBNBEvent.InputTuple,
      SellForBNBEvent.OutputTuple,
      SellForBNBEvent.OutputObject
    >;

    "SellForPDX(uint256,address,bool,uint256,uint256)": TypedContractEvent<
      SellForPDXEvent.InputTuple,
      SellForPDXEvent.OutputTuple,
      SellForPDXEvent.OutputObject
    >;
    SellForPDX: TypedContractEvent<
      SellForPDXEvent.InputTuple,
      SellForPDXEvent.OutputTuple,
      SellForPDXEvent.OutputObject
    >;

    "SlippageToleranceUpdated(uint256)": TypedContractEvent<
      SlippageToleranceUpdatedEvent.InputTuple,
      SlippageToleranceUpdatedEvent.OutputTuple,
      SlippageToleranceUpdatedEvent.OutputObject
    >;
    SlippageToleranceUpdated: TypedContractEvent<
      SlippageToleranceUpdatedEvent.InputTuple,
      SlippageToleranceUpdatedEvent.OutputTuple,
      SlippageToleranceUpdatedEvent.OutputObject
    >;
  };
}
